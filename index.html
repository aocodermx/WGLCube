<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Test control usage</title>
    <link rel="stylesheet" href="css/main.css" />
  </head>
  <body onload="setupWebGL();">
    <div id="cube"></div>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/SceneUtils.js"></script>
    <script>
      var cubeSize = 3;
      var cameraPosition = cubeSize * 1.4;
      var cubeArray = Array();
      var core = new THREE.Object3D();

      var scene  = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 45, document.getElementById("cube").offsetWidth / document.getElementById("cube").offsetHeight, 0.1, 1000 );
      var renderer = window.WebGLRenderingContext ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer();

      var deg2rad = function(degrees){return degrees*(Math.PI/180);}

      function setupWebGL(){
        camera.position.addScalar(cameraPosition);
        renderer.setClearColor(0xDDDDDD, 1);
        renderer.setSize( document.getElementById("cube").offsetWidth, document.getElementById("cube").offsetHeight );
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        document.getElementById("cube").appendChild(renderer.domElement);

        window.addEventListener('resize', function() {
          var WIDTH = document.getElementById("cube").offsetWidth,
          HEIGHT = document.getElementById("cube").offsetHeight;
          renderer.setSize(WIDTH, HEIGHT);
          camera.aspect = WIDTH / HEIGHT;
          camera.updateProjectionMatrix();
        });

        renderCube(scene);
        runGL();
      }

      function renderCube(scene){
        var geometry = new THREE.BoxGeometry( 0.99, 0.99, 0.99 );
        var material = new THREE.MeshFaceMaterial( [
          new THREE.MeshBasicMaterial({color:0xFF6600}), // Right  -> Orange
          new THREE.MeshBasicMaterial({color:0xFF0000}), // Left   -> Red
          new THREE.MeshBasicMaterial({color:0x00FF00}), // Top    -> Green
          new THREE.MeshBasicMaterial({color:0x0000FF}), // Bottom -> Blue
          new THREE.MeshBasicMaterial({color:0xFFFFFF}), // Front  -> White
          new THREE.MeshBasicMaterial({color:0xFFFF00})  // Back   -> Yellow
          ] );

        for(var z=-cubeSize/2 + 0.5; z<cubeSize/2; z++){
          for(var x=-cubeSize/2 + 0.5; x<cubeSize/2; x++){
            for(var y=-cubeSize/2 + 0.5; y<cubeSize/2; y++){
              var piece = new THREE.Mesh(geometry, material);
              piece.position.set(x, y, z);
              cubeArray.push(piece);
              scene.add(piece);
            }
          }
        }
        // Core point for rotations
        core.position.set(0,0,0);
        scene.add(core);
      }

      function moveOnAxis(axis, level, direction){
        var level = level - cubeSize/2 + 0.5;
        // validate axis in x,y,z
        if(axis != "x" && axis != "y" && axis != "z")
          return -1;
        for (var b=0; b<cubeArray.length; b++){
          if(Math.round(cubeArray[b].getWorldPosition()[axis]) === level ){
            THREE.SceneUtils.attach(cubeArray[b], scene, core);
          } else {
            console.log("level: ", level, "Position: ", Math.round(cubeArray[b].getWorldPosition()[axis]));
          }
        }

        switch(axis){
          case "x":
            core.rotation.x += direction*deg2rad(90);
            break;
          case "y":
            core.rotation.y += direction*deg2rad(90);
            break;
          case "z":
            core.rotation.z += direction*deg2rad(90);
            break;
        }
        core.updateMatrixWorld();
        for (var b=0; b<cubeArray.length; b++){
          if(Math.round(cubeArray[b].getWorldPosition()[axis]) === level){
            THREE.SceneUtils.detach(cubeArray[b], core, scene);
          } else {
            console.log("level: ", level, "Position: ", Math.round(cubeArray[b].getWorldPosition()[axis]));
          }
        }

        console.log("Scene:", scene.children.length);
        console.log("Core :", core.children.length);
      }

      function moveString(steps){
        for (var step in steps){
          switch(steps[step]){
            case "L":
              moveOnAxis("x", 0, 1);
              break;
            case "l":
              moveOnAxis("x", 0,-1);
              break;
            case "R":
              moveOnAxis("x", 2,-1);
              break;
            case "r":
              moveOnAxis("x", 2, 1);
              break;
            case "U":
              moveOnAxis("y", 2,-1);
              break;
            case "u":
              moveOnAxis("y", 2, 1);
              break;
            case "D":
              moveOnAxis("y", 0, 1);
              break;
            case "d":
              moveOnAxis("y", 0,-1);
              break;
            case "F":
              moveOnAxis("z", 2,-1);
              break;
            case "f":
              moveOnAxis("z", 2, 1);
              break;
            case "B":
              moveOnAxis("z", 0, 1);
              break;
            case "b":
              moveOnAxis("z", 0,-1);
              break;
            default:
              console.log("Invalid character", steps[step]);
              return -1;
          }
        }
      }

      function runGL() {
        requestAnimationFrame( runGL );
        renderer.render( scene, camera );
        controls.update();
      }
    </script>
  </body>
</html>
