<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Test control usage</title>
    <link rel="stylesheet" href="css/main.css" />
  </head>
    <div id="cube"></div>
  <body onload="setupWebGL();">
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script>
      var cubeSize = 3;
      var cameraPosition = cubeSize * 1.4;

      var scene  = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 45, document.getElementById("cube").offsetWidth / document.getElementById("cube").offsetHeight, 0.1, 1000 );
      var renderer = window.WebGLRenderingContext ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer();

      var deg2rad = function(degrees){return degrees*(Math.PI/180);}

      function setupWebGL(){
        camera.position.addScalar(cameraPosition);
        renderer.setClearColor(0xDDDDDD, 1);
        renderer.setSize( document.getElementById("cube").offsetWidth, document.getElementById("cube").offsetHeight );
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        document.getElementById("cube").appendChild(renderer.domElement);

        // Temporal grid
        var gridXY = new THREE.GridHelper(cubeSize, 1);
        gridXY.rotation.x = Math.PI/2;
        gridXY.setColors( new THREE.Color(0x000066), new THREE.Color(0x000066) );
        scene.add(gridXY);

        window.addEventListener('resize', function() {
          var WIDTH = document.getElementById("cube").offsetWidth,
          HEIGHT = document.getElementById("cube").offsetHeight;
          renderer.setSize(WIDTH, HEIGHT);
          camera.aspect = WIDTH / HEIGHT;
          camera.updateProjectionMatrix();
        });

        renderCube(scene);

        /* Testing animaiton options */

        runGL();
      }

      function renderCube(scene){
        var geometry = new THREE.BoxGeometry( 0.99, 0.99, 0.99 );
        var material = new THREE.MeshFaceMaterial( [
          new THREE.MeshBasicMaterial({color:0xFF0000}), // Left   -> Red
          new THREE.MeshBasicMaterial({color:0xFF6600}), // Right  -> Orange
          new THREE.MeshBasicMaterial({color:0x00FF00}), // Top    -> Green
          new THREE.MeshBasicMaterial({color:0x0000FF}), // Bottom -> Blue
          new THREE.MeshBasicMaterial({color:0xFFFFFF}), // Front  -> White
          new THREE.MeshBasicMaterial({color:0xFFFF00})  // Back   -> Yellow
          ] );

        for(var z=-cubeSize/2; z<cubeSize/2; z++){
          for(var x=-cubeSize/2; x<cubeSize/2; x++){
            for(var y=-cubeSize/2; y<cubeSize/2; y++){
              var piece = new THREE.Mesh(geometry, material);
              piece.position.set(x + 0.5, y + 0.5, z + 0.5);
              scene.add(piece);
            }
          }
        }
      }

      function runGL() {
        requestAnimationFrame( runGL );
        renderer.render( scene, camera );
        controls.update();
      }
    </script>
  </body>
</html>
