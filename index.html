<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Test control usage</title>
    <link rel="stylesheet" href="css/main.css" />
  </head>
  <body onload="setupWebGL();">
    <div id="cube"></div>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/SceneUtils.js"></script>
    <script>
      var cubeSize = 3;
      var cameraPosition = cubeSize * 1.4;
      var cubeArray = Array();

      var scene  = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 45, document.getElementById("cube").offsetWidth / document.getElementById("cube").offsetHeight, 0.1, 1000 );
      var renderer = window.WebGLRenderingContext ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer();

      var deg2rad = function(degrees){return degrees*(Math.PI/180);}

      var xContainer = new THREE.Object3D();
      var yContainer = new THREE.Object3D();
      var zContainer = new THREE.Object3D();

      function setupWebGL(){
        camera.position.addScalar(cameraPosition);
        renderer.setClearColor(0xDDDDDD, 1);
        renderer.setSize( document.getElementById("cube").offsetWidth, document.getElementById("cube").offsetHeight );
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        document.getElementById("cube").appendChild(renderer.domElement);

        scene.add(xContainer);
        scene.add(yContainer);
        scene.add(zContainer);

        // Temporal grid
        var gridXY = new THREE.GridHelper(cubeSize, 1);
        gridXY.rotation.x = Math.PI/2;
        gridXY.setColors( new THREE.Color(0x000066), new THREE.Color(0x000066) );
        scene.add(gridXY);

        window.addEventListener('resize', function() {
          var WIDTH = document.getElementById("cube").offsetWidth,
          HEIGHT = document.getElementById("cube").offsetHeight;
          renderer.setSize(WIDTH, HEIGHT);
          camera.aspect = WIDTH / HEIGHT;
          camera.updateProjectionMatrix();
        });

        renderCube(scene);
        runGL();
      }

      function renderCube(scene){
        var geometry = new THREE.BoxGeometry( 0.99, 0.99, 0.99 );
        var material = new THREE.MeshFaceMaterial( [
          new THREE.MeshBasicMaterial({color:0xFF6600}), // Right  -> Orange
          new THREE.MeshBasicMaterial({color:0xFF0000}), // Left   -> Red
          new THREE.MeshBasicMaterial({color:0x00FF00}), // Top    -> Green
          new THREE.MeshBasicMaterial({color:0x0000FF}), // Bottom -> Blue
          new THREE.MeshBasicMaterial({color:0xFFFFFF}), // Front  -> White
          new THREE.MeshBasicMaterial({color:0xFFFF00})  // Back   -> Yellow
          ] );

        for(var z=-cubeSize/2 + 0.5; z<cubeSize/2; z++){
          cubeArray[z] = Array();
          for(var x=-cubeSize/2 + 0.5; x<cubeSize/2; x++){
            cubeArray[z][x] = Array();
            for(var y=-cubeSize/2 + 0.5; y<cubeSize/2; y++){
              var piece = new THREE.Mesh(geometry, material);
              piece.position.set(x, y, z);
              cubeArray[z][x][y] = piece;
              scene.add(piece);
            }
          }
        }
        // Higlight centers
        cubeArray[1][0][0].scale.setZ(1.2);
        cubeArray[0][1][0].scale.setX(1.2);
        cubeArray[0][0][1].scale.setY(1.2);
        cubeArray[-1][0][0].scale.setZ(1.2);
        cubeArray[0][-1][0].scale.setX(1.2);
        cubeArray[0][0][-1].scale.setY(1.2);
        // Nedded for unknown reasons.
        xContainer.rotation.x = deg2rad(90);
        yContainer.rotation.y = deg2rad(90);
        zContainer.rotation.z = deg2rad(90);
      }



      function moveX(level, direction){
        level = level - cubeSize/2 + 0.5;
        for(var z=-cubeSize/2 + 0.5; z<cubeSize/2; z++){
          for(var y=-cubeSize/2 + 0.5; y<cubeSize/2; y++){
            xContainer.add(cubeArray[z][level][y]);
          }
        }
        xContainer.rotation.x = direction*deg2rad(90);
        for(var z=-cubeSize/2 + 0.5; z<cubeSize/2; z++){
          for(var y=-cubeSize/2 + 0.5; y<cubeSize/2; y++){
            newpos = cubeArray[z][level][y].getWorldPosition().clone();
            newrot = cubeArray[z][level][y].getWorldRotation().clone();
            xContainer.remove(cubeArray[z][level][y]);
            cubeArray[z][level][y].position.copy(newpos);
            cubeArray[z][level][y].rotation.copy(newrot);
            scene.add(cubeArray[z][level][y]);
          }
        }
      }


      function moveY(level, direction){
        level = level - cubeSize/2 + 0.5;
        for(var z=-cubeSize/2 + 0.5; z<cubeSize/2; z++){
          for(var x=-cubeSize/2 + 0.5; x<cubeSize/2; x++){
            yContainer.add(cubeArray[z][x][level]);
          }
        }
        yContainer.rotation.y = direction*deg2rad(90);
        for(var z=-cubeSize/2 + 0.5; z<cubeSize/2; z++){
          for(var x=-cubeSize/2 + 0.5; x<cubeSize/2; x++){
            newpos = cubeArray[z][x][level].getWorldPosition().clone();
            newrot = cubeArray[z][x][level].getWorldRotation().clone();
            yContainer.remove(cubeArray[z][x][level]);
            cubeArray[z][x][level].position.copy(newpos);
            cubeArray[z][x][level].rotation.copy(newrot);
            scene.add(cubeArray[z][x][level]);
          }
        }
      }

      function moveZ(level, direction){
        level = level - cubeSize/2 + 0.5;
        tmpArray = new Array();
        for(var x=-cubeSize/2 + 0.5; x<cubeSize/2; x++){
          tmpArray[x] = new Array();
          for(var y=-cubeSize/2 + 0.5; y<cubeSize/2; y++){
            tmpArray[x][y] = cubeArray[level][x][y].clone();
            zContainer.add(tmpArray[x][y]);
            zContainer.remove(cubeArray[level][x][y]);
          }
        }
        zContainer.rotation.z = direction*deg2rad(90);
        for(var x=-cubeSize/2 + 0.5; x<cubeSize/2; x++){
          for(var y=-cubeSize/2 + 0.5; y<cubeSize/2; y++){
            newpos = tmpArray[x][y].getWorldPosition().clone();
            newrot = tmpArray[x][y].getWorldRotation().clone();
            zContainer.remove(tmpArray[x][y]);
            tmpArray[x][y].position.copy(newpos);
            tmpArray[x][y].rotation.copy(newrot);
            scene.add(tmpArray[x][y]);
            cubeArray[level][x][y] = tmpArray[Math.round(newpos.x)][Math.round(newpos.y)];
          }
        }
      }

      function rotatePoint(x, y, direction){
        return [(-y * direction), x * direction];
      }

      function runGL() {
        requestAnimationFrame( runGL );
        renderer.render( scene, camera );
        controls.update();
      }
    </script>
  </body>
</html>
