<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>rubikgl-web</title>
    <link rel="stylesheet" href="style.css">
    <style type="text/css">
    body{
      margin:0;
      overflow:hidden;
      text-align:center;
      background:#424242;
    }
    #rubik-cube{
      position:absolute;
      width:100%;
      bottom:30%;
      top:0;
    }
    #rubik-steps-display{
      position:absolute;
      width:100%;
      height:10%;
      bottom:15%;
      color:white;
      overflow:hidden;
    }
    #rubik-steps-display p{
      margin:0;
    }
    #rubik-controls{
      position:absolute;
      width:100%;
      height:15%;
      bottom:0;
    }
    #rubik-controls button{
      height:90%;
      width:23%;
      font-size:auto;
    }
    </style>
  </head>
  <body onload="setup();">
    <div id="rubik-cube"></div>
    <div id="rubik-steps-display">
      <p id="rubik-steps"></p>
    </div>
    <div id="rubik-controls">
      <button class="icon-previous" id="prev"></button>
      <button class="icon-play"     id="playpause"></button>
      <button class="icon-stop"     id="stop"></button>
      <button class="icon-next"     id="next"></button>
    </div>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.min.js"></script>
    <script src="js/SceneUtils.min.js"></script>
    <script src="js/tween.min.js"></script>
    <script type="text/javascript">
var STEP_TIME = 500;
var cubeSize  = 2;
var aCube     = [];
var scene     = new THREE.Scene();
var stepsList   = [];
var currentStep = 0;

var isInstantMove = false;

var attachFace = false;
var detachFace = false;

var cubeCore = null;
var tween = null;

function setup() {
  var container = document.getElementById( "rubik-cube" );
  var renderer  = window.WebGLRenderingContext ? new THREE.WebGLRenderer( { antialias:true, preserveDrawingBuffer: true } ) : new THREE.CanvasRenderer();
  var camera    = new THREE.PerspectiveCamera( 45, container.offsetWidth / ( container.offsetHeight ), 0.1, 1000 );
  var controls  = new THREE.OrbitControls( camera, renderer.domElement );

  controls.noPan = true;
  renderer.setClearColor( 0x424242, 1 );
  renderer.setSize( container.offsetWidth, container.offsetHeight );
  container.appendChild( renderer.domElement );

  var size = window.frameElement.getAttribute( "data-size" );
  var rubikSteps = document.getElementById( "rubik-steps" );
  var stepString = window.frameElement.getAttribute( "data-steps" );
  cubeSize = size ? size : 3;
  rubikSteps.innerHTML = stepString;

  renderCube();
  // console.log(renderer.domElement.toDataURL());
  resizeControls();

  function onResize() {
    var container = document.getElementById( "rubik-cube" );
    var WIDTH  = container.offsetWidth, HEIGHT = container.offsetHeight;
    renderer.setSize( WIDTH, HEIGHT );
    camera.aspect = WIDTH / HEIGHT;
    camera.updateProjectionMatrix();
    resizeControls();
  }

  window.addEventListener( "resize", onResize);

  camera.position.addScalar( cubeSize * 1.4 );
  runGL( renderer, camera, controls );
}

function renderCube() {
  var geometry = new THREE.BoxGeometry( 0.98, 0.98, 0.98 );
  var material = new THREE.MeshFaceMaterial( [
    new THREE.MeshBasicMaterial( { color:0xFF6600 } ), // Right  -> Orange
    new THREE.MeshBasicMaterial( { color:0xFF0000 } ), // Left   -> Red
    new THREE.MeshBasicMaterial( { color:0x00FF00 } ), // Top    -> Green
    new THREE.MeshBasicMaterial( { color:0x0000FF } ), // Bottom -> Blue
    new THREE.MeshBasicMaterial( { color:0xFFFFFF } ), // Front  -> White
    new THREE.MeshBasicMaterial( { color:0xFFFF00 } )  // Back   -> Yellow
    ] );

  for ( var z = -cubeSize / 2 + 0.5; z < cubeSize / 2; z++ ) {
    for ( var x = -cubeSize / 2 + 0.5; x < cubeSize / 2; x++ ) {
      for ( var y = -cubeSize / 2 + 0.5; y < cubeSize / 2; y++ ) {
        var piece = new THREE.Mesh( geometry, material );
        piece.position.set( x, y, z );
        aCube.push( piece );
        scene.add( piece );
      }
    }
  }

  var initString = window.frameElement.getAttribute( "data-start" );
  isInstantMove = true;
  parseStepString( initString );
}

function resetCube() {
  for ( var i = 0, len = aCube.length; i < len; i++ )
    scene.remove( aCube[i] );
  aCube = [];
  renderCube( scene );
}

function attachFaceToCore( cubeCore, axis, layer ) {
  var level = layer - cubeSize / 2 + 0.5 - 1;

  scene.add( cubeCore );

  for ( var b = 0, len = aCube.length; b < len; b++ )
    if ( aCube[b].getWorldPosition()[axis] === level )
      THREE.SceneUtils.attach( aCube[b], scene, cubeCore );
}

function detachFaceFromCore( cubeCore, axis, layer ) {
  var level = layer - cubeSize / 2 + 0.5 - 1;

  for ( var b = 0, len = aCube.length; b < len; b++ )
    if ( aCube[b].getWorldPosition()[axis] === level )
      THREE.SceneUtils.detach( aCube[b], cubeCore, scene );

  scene.remove( cubeCore );
}

function parseStepString( steps ) {
  if ( steps === null )
    return -1;

  if ( steps.length === 0 )
    return -1;

  if ( steps === "*" ) // Randomize from WCA scrambler
    steps = "FUR";  // Steps from internet or algorithm

  stepsList = [];
  currentStep = 0;

  steps += " ";
  var pos = 0;
  var char = '';
  var tok = '';

  var STATE_START = 0;
  var STATE_LAYER = 1;
  var STATE_AXIS  = 2;
  var STATE_TIMES = 3;
  var STATE_DIRECTION = 4;
  var STATE_END = 5;

  while ( typeof char !== "undefined" ) {
    var step_axis = "";
    var step_layer = 1;
    var step_direction = 1;
    var step_times = 1;
    var STATE = STATE_START;

    while ( STATE !== STATE_END ) {
      char = steps[pos];
      //console.log("CHAR:",char, " STATE:", STATE);
      switch ( STATE ) {
        case STATE_START:
          if ( !/\s/g.test( char ) ) {
            STATE = STATE_LAYER;
            pos--;
          }
          if ( typeof char === "undefined" ) {
            STATE = STATE_END;
          }
          break;
        case STATE_LAYER:
          var result = parseInt( char );
          if ( isNaN ( result ) ) {
            STATE = STATE_AXIS;
            pos--;
            if ( tok !== "" ) {
              step_layer = parseInt( tok );
              tok = "";
            }
          } else {
            tok += char;
          }
          break;
        case STATE_AXIS:
          switch ( char ) {
            case "R":
              step_layer = cubeSize - step_layer + 1;
              step_direction *= -1;
            case "L":
              step_axis = "x";
              break;
            case "U":
              step_layer = cubeSize - step_layer + 1;
              step_direction *= -1;
            case "D":
              step_axis = "y";
              break;
            case "F":
              step_layer = cubeSize - step_layer + 1;
              step_direction *= -1;
            case "B":
              step_axis = "z";
              break;
            default:
              console.log( "FACE to move is incorrect" );
              console.log("Saliendo");
              return -1;
          }
          STATE = STATE_TIMES;
          break;
        case STATE_TIMES:
          var result2 = parseInt( char );
          if ( isNaN( result2 ) ) {
            STATE = STATE_DIRECTION;
            pos--;
            if ( tok !== "" ) {
              step_times = parseInt( tok );
              tok = "";
            }
          } else {
            tok += char;
          }
          break;
        case STATE_DIRECTION:
          if ( char === "\'" )
            step_direction *= -1;
          else
            pos--;
          if ( isInstantMove )
            applyInstantSteps ( step_axis, step_layer, step_times * step_direction * 90 * ( Math.PI / 180 ) );
          else
            stepsList.push( { layer: step_layer , axis: step_axis, times: step_times, radians: step_times * step_direction * 90 * ( Math.PI / 180 ) } );
          STATE = STATE_END;
          break;
        default:
          console.log( "Fatal error, state unknown." );
          return -1;
      }
      pos++;
    }
  }
  if(!isInstantMove)
    attachFace = true;
  else
    isInstantMove = false;

  //for(var i = 0, len = stepsList.length; i < len; i++)
    //console.log(stepsList[i]);
}

function applyInstantSteps(axis, layer, radians) {
  cubeCore = new THREE.Object3D();
  attachFaceToCore( cubeCore, axis, layer );
  switch ( axis ) {
    case "x":
      cubeCore.rotation.x += radians;
      break;
    case "y":
      cubeCore.rotation.y += radians;
      break;
    case "z":
      cubeCore.rotation.z += radians;
      break;
    }
  cubeCore.updateMatrixWorld();
  detachFaceFromCore( cubeCore, axis, layer );
}


function applySteps() {
  TWEEN.update();
  if ( attachFace ) {
    cubeCore = new THREE.Object3D();
    attachFaceToCore( cubeCore, stepsList[currentStep].axis, stepsList[currentStep].layer );
    tween = new TWEEN.Tween( cubeCore.rotation );
    switch ( stepsList[currentStep].axis ) {
      case "x":
        tween.to( { x: stepsList[currentStep].radians }, STEP_TIME * stepsList[currentStep].times );
        break;
      case "y":
        tween.to( { y: stepsList[currentStep].radians }, STEP_TIME * stepsList[currentStep].times );
        break;
      case "z":
        tween.to( { z: stepsList[currentStep].radians }, STEP_TIME * stepsList[currentStep].times );
        break;
    }
    tween.onComplete(
      function() {
        cubeCore.updateMatrixWorld();
        detachFace = true;
      }
    );
    attachFace = false;
    tween.start();
  }
  if ( detachFace ) {
    detachFaceFromCore( cubeCore, stepsList[currentStep].axis, stepsList[currentStep].layer );
    detachFace = false;
    currentStep++;
    if ( currentStep < stepsList.length )
      attachFace = true;
  }
}

function runGL( renderer, camera, controls ) {
  requestAnimationFrame( function() { runGL( renderer, camera, controls ); } );
  renderer.render( scene, camera );
  applySteps();
  controls.update();
}

function resizeControls() {
  var rubikControl = document.getElementById( "rubik-controls" );
  var controlButtons = rubikControl.getElementsByTagName( "button" );
  var height = ( controlButtons[0].offsetHeight * 0.6 ) + "px";
  for ( var i = 0, len = controlButtons.length; i < len; i++ ) {
    controlButtons[i].style.fontSize = height;
  }
}

var buttonPlay = document.getElementById( "playpause" );
buttonPlay.onclick = function() {
  resetCube();
  parseStepString( window.frameElement.getAttribute( "data-steps" ) );
};

var buttonStop = document.getElementById( "stop" );
buttonStop.onclick = function() {
  resetCube();
};

    /*
    if ( typeof module !== "undefined" && module.exports ) {
      module.exports = WEBGLCUBE;
    }
    */
    </script>
  </body>
</html>
