var WGL = ( function ( params ) {

    /*
    *  Object to represent the 3D Cube, exposing an API to manipulate the cube.
    *  The cube can be in either two modes for better performance:
    *
    *  * Preview mode:
    *       In this mode a simple preview is presented until the user interact
    *       with the control, at this point the cube change it's mode to
    *       interactive.
    *
    *  * Interactive mode:
    *       In this mode the 3D code is executed to render the cube, so the user
    *       can now interact with the cube.
    */
    params.Core = function ( dom_container ) {
        var self = this;   // To avoid this confusion in callback functions.

        // Public properties.
        self.size      = null; // Size for the cube
        self.STEP_TIME = 750;  // Time for each single move

        var RootContainer = null;   // Root DOM Container
        var CubeArray     = [];     // Array to hold 3d cubes
        var CubesToShow   = [];     // Array to store the index for the pieces to highlight
        var CubeCore      = null;   // Core object, needed to perform movements
        var CubeContainer = null;   // Container for the 3d cube

        var tween            = null;  // For animating the cube
        var animationFrameId = null;  // Animation frame id to stop animation.
        var animationStart   = false; // start animation.
        var animationAxis    = null;  // axis to move when an animation is performed.
        var animationLayer   = null;  // layer to move when an animation is performed.
        var animationRadians = null;  // radians to move when an animation is performed.
        var animationCount   = null;  // time factor when an animation is performed.
        var animationRunning = null;  // Flag when animation is running, to avoid cube malformation.

        var animationFinishCallback = null; // Executed when the animation finishes.

        var scene    = null;   // WebGL Scene
        var renderer = null;   // WebGL Renderer
        var camera   = null;   // WebGL Camera
        var controls = null;   // WebGL Controls


        /*
         *  Function to draw the default HTML layout to display before load the WebGL
         *  Cube, other initialization code goes here.
         */
        function init ( dom_container ) {
            RootContainer = dom_container;
            self.size     = RootContainer.getAttribute ( 'data-size'  );
            if ( typeof self.size === 'undefined' ) {
                console.log ( 'data-size parameter needed in order to render cube.' );
                return 0;
            }

            var CubesToShowString = RootContainer.getAttribute ( "data-show" );
            if ( CubesToShowString !== null) {
                CubesToShow = CubesToShowString.split( "," );
            }

            var div_preview       = document.createElement ( 'div' );
            div_preview.className = 'preview';
            div_preview.innerHTML =
                "<div class='square s1'></div>" +
                "<div class='square s2'></div>" +
                "<div class='square s3'></div>" +
                "<div class='square s4'></div>";

            var div_cube       = document.createElement ( 'div' );
            div_cube.className = 'cube';

            RootContainer.appendChild ( div_preview );
            RootContainer.appendChild ( div_cube );
        }


        /*
         *  Function to change from preview mode to interactive mode.
         */
        this.to_interactive_mode = function ( ) {
            var div_preview   = RootContainer.getElementsByClassName ( 'preview' )[0];
            div_preview.classList.remove ( 'util-show' );
            div_preview.classList.add    ( 'util-hide' );
            // div_preview.style = 'display:none; ';

            var div_cube = RootContainer.getElementsByClassName ( 'cube' )[0];
            div_cube.classList.remove ( 'util-hide' );
            div_cube.classList.add    ( 'util-show' );
            // div_cube.style = 'display:block;';

            // Load WGL
            init3d ( );
        };


        /*
        *  Function to change from interactive mode to preview mode.
        */
        this.to_preview_mode = function ( ) {
            var div_preview   = RootContainer.getElementsByClassName ( 'preview' )[0];
            div_preview.classList.remove ( 'util-hide' );
            div_preview.classList.add    ( 'util-show' );
            // div_preview.style = 'display:block;';

            var div_cube = RootContainer.getElementsByClassName ( 'cube' )[0];
            div_cube.classList.remove ( 'util-show' );
            div_cube.classList.add    ( 'util-hide' );
            // div_cube.style = 'display:none;';

            cancelAnimationFrame ( animationFrameId );
            // TODO: Update threejs version used.
            // renderer.context.canvas.loseContext ( );
            if ( renderer != null ) {
                renderer.forceContextLoss ( );
                renderer = null;
                camera   = null;
                controls = null;

                while ( CubeContainer.lastChild ) CubeContainer.removeChild( CubeContainer.lastChild );
            }

        };


        /*
        *    Function to reset the cube to the original position.
        */
        this.Reset = function (  ) {
            if ( tween != null && animationRunning )
                tween.stop ( );
            else
                renderCube ( scene );
        };


        /*
        *   Function to parse a move string based in the form:
        *
        *       [Layer]Face[Times][Direction]
        *
        *   Where:
        *
        *       stepString    : the steps string to apply.
        *       animated      : true if animation will be executed, false otherwise.
        *       callback_start: a function to be executed when animation start.
        *       callback_end  : a function to be executed when animation finishes,
        *                       if animated is false, this will be ignored.
        *
        *       TODO: Implement Face X Y Z to rotate the entire cube.
        */
        this.Move = function ( stepString, animated, callback_start, callback_end ) {

            if ( animationRunning ) {
                console.log ( "Animation not finished, try again later.");
                return;
            }

            if ( animated ) {
                callback_start ( );
            }

            stepString  += " ";

            var position = 0;
            var char     = '';
            var token    = '';

            var STATE_START     = 0;
            var STATE_LAYER     = 1;
            var STATE_AXIS      = 2;
            var STATE_TIMES     = 3;
            var STATE_DIRECTION = 4;
            var STATE_END       = 5;

            while ( typeof char !== "undefined" ) {

                var step_axis      = "";
                var step_layer     = 1;
                var step_direction = 1;
                var step_times     = 1;

                var STATE = STATE_START;

                while ( STATE !== STATE_END ) {
                    char = stepString[position];
                    switch ( STATE ) {
                        case STATE_START:
                            if ( !/\s/g.test( char ) ) {
                                STATE = STATE_LAYER;
                                position--;
                            }
                            if ( typeof char === "undefined" ) {
                                STATE = STATE_END;
                            }
                            break;
                        case STATE_LAYER:
                            var result = parseInt( char );
                            if ( isNaN ( result ) ) {
                                STATE = STATE_AXIS;
                                position--;
                                if ( token !== "" ) {
                                    step_layer = parseInt( token );
                                    token = "";
                                }
                            } else {
                                token += char;
                            }
                            break;
                        case STATE_AXIS:
                            switch ( char ) {
                                case "R":
                                    step_layer = self.size - step_layer + 1;
                                    step_direction *= -1;
                                case "L":
                                    step_axis = "x";
                                    break;
                                case "U":
                                    step_layer = self.size - step_layer + 1;
                                    step_direction *= -1;
                                case "D":
                                    step_axis = "y";
                                    break;
                                case "F":
                                    step_layer = self.size - step_layer + 1;
                                    step_direction *= -1;
                                case "B":
                                    step_axis = "z";
                                    break;
                                default:
                                    console.log( "FACE to move is incorrect" );
                                    return -1;
                            }
                            STATE = STATE_TIMES;
                            break;
                        case STATE_TIMES:
                            var result2 = parseInt( char );
                            if ( isNaN( result2 ) ) {
                                STATE = STATE_DIRECTION;
                                position--;
                                if ( token !== "" ) {
                                    step_times = parseInt( token );
                                    token = "";
                                }
                            } else {
                                token += char;
                            }
                            break;
                        case STATE_DIRECTION:
                            if ( char === "\'" )
                                step_direction *= -1;
                            else
                                position--;

                            // Check for animation
                            if ( animated === true ) {
                                animationAxis    = step_axis;
                                animationLayer   = step_layer;
                                animationRadians = step_times * step_direction * 90 * ( Math.PI / 180 );
                                animationCount   = step_times;
                                animationStart   = true;
                                animationFinishCallback = callback_end;
                            } else {
                                moveFaceInstantly ( step_axis, step_layer, step_times * step_direction * 90 * ( Math.PI / 180 ) );
                            }

                            STATE = STATE_END;
                            break;
                        default:
                            console.log( "Fatal error, state unknown." );
                            return -1;
                    }
                    position++;
                }
            }
        };




        /*
        *  Function to initialize WebGL variables and environment.
        */
        function init3d ( ) {
            CubeContainer = RootContainer.getElementsByClassName ( "cube" )[0];

            scene     = new THREE.Scene();
            renderer  = window.WebGLRenderingContext ? new THREE.WebGLRenderer ( { antialias:true, preserveDrawingBuffer: true } ) : new THREE.CanvasRenderer ( );
            camera    = new THREE.PerspectiveCamera ( 45, CubeContainer.offsetWidth / ( CubeContainer.offsetHeight ), 0.1, 1000 );
            controls  = new THREE.OrbitControls ( camera, renderer.domElement );

            controls.enablePan = false;
            renderer.setClearColor    ( 0xD8D8D8, 1 );
            renderer.setSize          ( CubeContainer.offsetWidth, CubeContainer.offsetHeight );
            CubeContainer.appendChild ( renderer.domElement );

            renderCube ( );

            // Event listeners for cube container
            CubeContainer.addEventListener( "resize", onResize );

            camera.position.addScalar ( self.size * 1.4 );
            wglLoop ( renderer, camera, controls );
        }


        /*
        *  Function to draw the cube in the WebGL environment.
        */
        function renderCube ( ) {
            for ( var i = 0, len = CubeArray.length; i < len; i++ )
                scene.remove ( CubeArray[i] );

            CubeArray = [];

            var
                geometry = new THREE.BoxGeometry ( 0.98, 0.98, 0.98 ),
                material = new THREE.MeshFaceMaterial ( [
                    new THREE.MeshBasicMaterial ( { color:0xFF6600 } ), // Right  -> Orange
                    new THREE.MeshBasicMaterial ( { color:0xFF0000 } ), // Left   -> Red
                    new THREE.MeshBasicMaterial ( { color:0x00FF00 } ), // Top    -> Green
                    new THREE.MeshBasicMaterial ( { color:0x0000FF } ), // Bottom -> Blue
                    new THREE.MeshBasicMaterial ( { color:0xFFFFFF } ), // Front  -> White
                    new THREE.MeshBasicMaterial ( { color:0xFFFF00 } )  // Back   -> Yellow
                ] ),
                blackMaterial = new THREE.MeshFaceMaterial ( [
                    new THREE.MeshBasicMaterial ( { color:0x848484 } ), // Right  -> Orange
                    new THREE.MeshBasicMaterial ( { color:0x848484 } ), // Left   -> Red
                    new THREE.MeshBasicMaterial ( { color:0x848484 } ), // Top    -> Green
                    new THREE.MeshBasicMaterial ( { color:0x848484 } ), // Bottom -> Blue
                    new THREE.MeshBasicMaterial ( { color:0x848484 } ), // Front  -> White
                    new THREE.MeshBasicMaterial ( { color:0x848484 } )  // Back   -> Yellow
                ] );

            for ( var z = -self.size / 2 + 0.5; z < self.size / 2; z++ ) {
                for ( var x = -self.size / 2 + 0.5; x < self.size / 2; x++ ) {
                    for ( var y = -self.size / 2 + 0.5; y < self.size / 2; y++ ) {
                        var piece = null;
                        if( CubesToShow.length !== 0 && CubesToShow.indexOf( CubeArray.length.toString() ) < 0 ){
                            piece = new THREE.Mesh( geometry, blackMaterial );
                        } else {
                            piece = new THREE.Mesh( geometry, material );
                        }
                        piece.position.set( x, y, z );
                        CubeArray.push( piece );
                        scene.add( piece );
                    }
                }
            }
        }


        /*
        *  Utility function attach all the cubes from a face to a core object.
        */
        function attachFaceToCore( CubeCore, axis, layer ) {
            var level = layer - self.size / 2 + 0.5 - 1;

            scene.add ( CubeCore );

            for ( var b = 0, len = CubeArray.length; b < len; b++ ) {
                if ( ( CubeArray[b].getWorldPosition ( )[axis] ) === level ) {
                    THREE.SceneUtils.attach ( CubeArray[b], scene, CubeCore );
                }
            }
        }


        /*
        *  Utility function to move cube faces detaching it from a core object
        */
        function detachFaceFromCore ( CubeCore, axis, layer ) {
            var level = layer - self.size / 2 + 0.5 - 1;

            for ( var b = 0, len = CubeArray.length; b < len; b++ ) {
                if ( ( CubeArray[b].getWorldPosition ( )[axis] ) === level ) {
                    THREE.SceneUtils.detach ( CubeArray[b], CubeCore, scene );
                }
            }

            scene.remove ( CubeCore );
        }


        /*
        *  Runs an animation if it exists.
        */
        function runAnimation ( ) {
            TWEEN.update ( );

            if ( animationStart ) {
                CubeCore = new THREE.Object3D ( );
                attachFaceToCore ( CubeCore, animationAxis, animationLayer );
                tween = new TWEEN.Tween ( CubeCore.rotation );
                switch ( animationAxis ) {
                    case "x":
                        tween.to ( { x: animationRadians }, self.STEP_TIME * animationCount );
                        break;
                    case "y":
                        tween.to ( { y: animationRadians }, self.STEP_TIME * animationCount );
                        break;
                    case "z":
                        tween.to ( { z: animationRadians }, self.STEP_TIME * animationCount );
                        break;
                }
                tween.onStop (
                    function ( ) {
                        CubeCore.updateMatrixWorld ( );
                        detachFaceFromCore ( CubeCore, animationAxis, animationLayer );
                        animationRunning = false;
                        renderCube( scene );

                        // console.log ( "Tween onStop called" );
                    }
                );
                tween.onComplete (
                    function ( ) {
                        CubeCore.updateMatrixWorld ( );
                        detachFaceFromCore ( CubeCore, animationAxis, animationLayer );
                        animationRunning = false;
                        animationFinishCallback ( );

                        // console.log ( "Tween onComplete called" );
                    }
                );
                animationStart   = false;
                animationRunning = true;
                tween.start();
            }
        }


        /*
        *  Function to move a face for the cube.
        */
        function moveFaceInstantly ( axis, layer, radians ) {
            CubeCore = new THREE.Object3D ( );
            attachFaceToCore ( CubeCore, axis, layer );
            switch ( axis ) {
                case "x":
                    CubeCore.rotation.x += radians;
                    break;
                case "y":
                    CubeCore.rotation.y += radians;
                    break;
                case "z":
                    CubeCore.rotation.z += radians;
                    break;
            }
            CubeCore.updateMatrixWorld ( );
            detachFaceFromCore ( CubeCore, axis, layer );
        }


        /*
        *  Render loop
        */
        function wglLoop ( renderer, camera, controls ) {
            animationFrameId = requestAnimationFrame ( function ( ) { wglLoop ( renderer, camera, controls ); } );
            renderer.render ( scene, camera );
            runAnimation ( );
            controls.update ( );
        }



        // Event Listeners declaration.




        /*
        *  Function to resize the WebGL environment.
        */
        function onResize ( ) {
            var WIDTH  = self.CubeContainer.offsetWidth;
            var HEIGHT = self.CubeContainer.offsetHeight;

            renderer.setSize ( WIDTH, HEIGHT );
            camera.aspect = WIDTH / HEIGHT;
            camera.updateProjectionMatrix ( );
            // this.resizeControls ( );
        }


        init ( dom_container );     // Initialization for variables and layout
    };

    return params;
} ( WGL || { } ) );

var WGL = ( function ( params ) {

    /*
    *   Manager to find and load all cubes, and change it's mode to preview if
    *   they are not shown in screen.
    *
    */
    params.Manager = function ( dom_container ) {

        function init ( ) {
            var
                players = [],
                dom_players = document.getElementsByClassName ( 'wglcube_player' );

            for ( var i = 0; i< dom_players.length; i++ ) {
                players.push ( new WGL.Player ( dom_players[i] ) );
            }

            window.addEventListener('scroll', function ( e ) {
                for ( var i = 0; i< dom_players.length; i++ ) {
                    if ( !players[i].isPreview ( ) ) {
                        players[i].isScrolledIntoView ( );
                    }
                }
            } );

        }

        init ( dom_container );     // Initialization for variables and layout
    };

    return params;
} ( WGL || { } ) );

// Code for a smallest ready implementation from http://dustindiaz.com/smallest-domready-ever
function r(f){/in/.test(document.readyState)?setTimeout('r('+f+')',9):f();}

r ( function ( ) {
    var WGLCube = new WGL.Manager ( );
} );

var WGL = ( function ( params ) {

    /*
    *  Object to represent an algorithm player to play, pause move forward or
    *  backward step by step and stop the algorithm execution, the player can
    *  be in one of the folowing two modes:
    *
    *  * Preview mode:
    *       In this mode a simple preview is presented until the user interact
    *       with the control, at this point the player change it's mode to
    *       interactive.
    *
    *  * Interactive mode:
    *       In this mode the 3D code is executed to render the cube and to display
    *       the controls to manipulate the player, so the user can interact with
    *       the player.
    *
    */
    params.Player = function ( dom_container ) {
        var self = this;   // To avoid this confusion in callback functions.

        var core           = null;
        var RootContainer  = null;

        var player_preview = true;
        var player_step    = 0;
        var player_init    = null;
        var player_steps   = null;
        var player_forward = true;
        var player_playing = false;


        function init ( dom_container ) {
            RootContainer = dom_container;

            core         = new WGL.Core ( RootContainer );
            player_init  =   RootContainer.getAttribute ( 'data-init' );
            player_steps = ( RootContainer.getAttribute ( 'data-steps' ) ).split( ' ' );
            if ( player_steps === null ) {
                console.log ( 'data-steps needed in order to display an algorithm execution.' );
            }

            // core.STEP_TIME = 2500; // For test pruporses.

            var div_step_list = document.createElement ( 'div'    );
            var div_controls  = document.createElement ( 'div'    );
            var div_hint      = document.createElement ( 'div'    );

            var button_prev   = document.createElement ( 'button' );
            var button_stop   = document.createElement ( 'button' );
            var button_play   = document.createElement ( 'button' );
            var button_next   = document.createElement ( 'button' );
            var button_close  = document.createElement ( 'button');

            div_step_list.className = "steps-container";
            div_controls.className  = "controls";
            div_hint.className      = "hint";

            button_prev.className   = 'icon-previous';
            button_stop.className   = 'icon-stop';
            button_play.className   = 'icon-play play-pause';
            button_next.className   = 'icon-next';
            button_close.className  = 'icon-close';

            for ( var i = 0; i < player_steps.length; i++ ) {
              var span_step       = document.createElement ( 'span' );
              span_step.innerHTML = player_steps[i];
              span_step.className = 'step_' + i;

              div_step_list.appendChild ( span_step );
            }
            div_hint.innerHTML = "Click to load 3D";

            button_prev.addEventListener   ( 'click', on_button_prev );
            button_stop.addEventListener   ( 'click', on_button_stop );
            button_play.addEventListener   ( 'click', on_button_play );
            button_next.addEventListener   ( 'click', on_button_next );
            button_close.addEventListener  ( 'click', self.to_preview_mode );
            RootContainer.addEventListener ( 'click', self.to_interactive_mode );

            div_controls.appendChild  ( button_prev  );
            div_controls.appendChild  ( button_stop  );
            div_controls.appendChild  ( button_play  );
            div_controls.appendChild  ( button_next  );
            div_controls.appendChild  ( button_close );

            RootContainer.appendChild ( div_step_list );
            RootContainer.appendChild ( div_hint );
            RootContainer.appendChild ( div_controls );

            var font_size = 1;
            while ( div_step_list.scrollHeight != div_step_list.offsetHeight ) {
                font_size -= 0.01;
                div_step_list.style.fontSize = font_size + "em";
                if ( font_size < 0.2 )
                    break;
            }
        }

        this.to_interactive_mode = function ( e ) {
            player_preview = false;

            var div_controls = RootContainer.getElementsByClassName ( 'controls' )[0];
            div_controls.classList.remove ( 'util-hide' );
            div_controls.classList.add    ( 'util-show' );
            // div_controls.style = 'display:block;';

            var div_hint  = RootContainer.getElementsByClassName ( 'hint' )[0];
            div_hint.classList.remove ( 'util-show' );
            div_hint.classList.add    ( 'util-hide' );
            // div_hint.style = 'display:none;';

            // RootContainer.style = 'cursor:inherit;';
            RootContainer.classList.remove ( 'util-cursor-hand' );
            RootContainer.classList.add    ( 'util-cursor-none' );

            core.to_interactive_mode ( );
            core.Move ( player_init, false, null );
            on_button_stop ( );
            RootContainer.removeEventListener ( 'click', self.to_interactive_mode );
        };

        this.to_preview_mode = function ( e ) {
            player_preview = true;

            var div_controls = RootContainer.getElementsByClassName ( 'controls' )[0];
            div_controls.classList.remove ( 'util-show' );
            div_controls.classList.add    ( 'util-hide' );
            // div_controls.style = 'display:none;';

            var div_hint  = RootContainer.getElementsByClassName ( 'hint' )[0];
            div_hint.classList.remove ( 'util-hide' );
            div_hint.classList.add    ( 'util-show' );
            // div_hint.style = 'display:block;';

            // RootContainer.style = 'cursor:block;cursor:hand;';
            RootContainer.classList.remove ( 'util-cursor-none' );
            RootContainer.classList.add    ( 'util-cursor-hand' );

            core.to_preview_mode ( );
            RootContainer.addEventListener ( 'click', self.to_interactive_mode );

            if ( typeof e !== 'undefined')
                e.cancelBubble = true;
        };

        this.isPreview = function ( ) {
            return player_preview;
        };

        this.isScrolledIntoView = function ( ) {
            var elemTop    = RootContainer.getBoundingClientRect().top;
            var elemBottom = RootContainer.getBoundingClientRect().bottom;

            var isVisible = (elemBottom >= 0) && (elemTop <= window.innerHeight);

            if ( !isVisible ) {
                self.to_preview_mode ( );
            }
            return isVisible;
        };

        function on_button_prev ( ) {

            if ( player_forward ) {
                player_step--;
                player_forward = false;
            }

            var inverted_step = player_steps [ player_step ].trim ( );
            if ( inverted_step.indexOf ( "'" ) !== -1 ) {
                inverted_step.replace ( "'", "" );
            } else {
                inverted_step += "'";
            }

            var span_step = RootContainer.getElementsByClassName ( 'step_' + player_step )[0];
            core.Move ( inverted_step, true, function ( ) {
                if ( typeof span_step !== 'undefined' ) {
                    span_step.classList.add ( 'current-step' );
                }
            }, function ( ) {
                player_step--;

                if ( typeof span_step !== 'undefined' )
                    span_step.classList.remove ( 'current-step' );
            } );
        }

        function on_button_stop ( ) {

            var span_step = RootContainer.getElementsByClassName ( 'step_' + player_step )[0];
            if ( typeof span_step !== 'undefined' )
                span_step.classList.remove ( 'current-step' );

            player_step    = 0;
            player_forward = true;
            player_playing = false;

            core.Reset ( );
            core.Move ( player_init, false );

            var button_play = RootContainer.getElementsByClassName ( 'play-pause' )[0];
            button_play.classList.remove ( 'icon-pause' );
            button_play.classList.add    ( 'icon-play' );
        }

        // TODO: Check the controls behaviour.
        function on_button_play ( e ) {

            if ( typeof e !== 'undefined' ) {
                player_playing = !player_playing;

                var button_play = RootContainer.getElementsByClassName ( 'play-pause' )[0];
                if ( player_playing ) {
                    button_play.classList.remove ( 'icon-play' );
                    button_play.classList.add    ( 'icon-pause' );
                } else {
                    button_play.classList.remove ( 'icon-pause' );
                    button_play.classList.add    ( 'icon-play' );
                }
            }

            if ( player_playing ) {
                if ( player_step >= player_steps.length ) {
                    on_button_stop ( );
                    return;
                }

                var span_step = RootContainer.getElementsByClassName ( 'step_' + player_step )[0];

                core.Move ( player_steps [ player_step ], true, function ( ) {
                    if ( typeof span_step !== 'undefined' ) {
                        span_step.classList.add ( 'current-step' );
                    }
                }, function ( ) {
                    player_step++;

                    if ( typeof span_step !== 'undefined' )
                        span_step.classList.remove ( 'current-step' );

                    on_button_play ( );
                } );
            }

        }

        function on_button_next ( ) {
            if ( player_step >= player_steps.length ) {
                on_button_stop ( );
                return;
            }

            if ( !player_forward ) {
                player_step++;
                player_forward = true;
            }

            var span_step = RootContainer.getElementsByClassName ( 'step_' + player_step )[0];

            core.Move ( player_steps [ player_step ], true, function ( ) {
                if ( typeof span_step !== 'undefined' ) {
                    span_step.classList.add ( 'current-step' );
                }

            }, function ( ) {
                player_step++;
                if ( typeof span_step !== 'undefined' )
                    span_step.classList.remove ( 'current-step' );
            } );
        }

        init ( dom_container );
    };

    return params;
} ( WGL || { } ) );
